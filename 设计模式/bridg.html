<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>桥接模式</title>
</head>

<body>
    <script type="text/javascript">
    // 在实现API的时候,桥梁模式最容易立即付出实施
    // 桥梁模式可以用来弱化它与使用它的类和对象之间的耦合，就是将抽象与其实现隔离开来，以便二者独立变化；这种模式对于JavaScript中常见的时间驱动的编程有很大益处，桥梁模式最常见和实际的应用场合之一是时间监听器回调函数。先分析一个不好的示例：
    //错误的方式
    //这个API根据事件监听器回调函数的工作机制，事件对象被作为参数传递给这个函数。本例中并没有使用这个参数，而只是从this对象获取ID。
    　　

    // 桥梁模式还可以用于连接公开的API代码和私有的实现代码，还可以把多个类连接在一起。在文章封装介绍的部分提到过特权方法，也是桥梁模式的一种特例。
    addEvent(element, 'click', getBeerById);　　
    function getBeerById(e) {　　
        var id = this.id;　　
        asyncRequest('GET', 'beer.url?id=' + id, function(resp) {　　 //Callback response
            　　
            console.log('Requested Beer: ' + resp.responseText);　　
        });　　
    }

    　　 //好的方式
    　　 //从逻辑上分析，把id传给getBeerById函数式合情理的，且回应结果总是通过一个回调函数返回。这么理解，我们现在做的是针对接口而不是实现进行编程，用桥梁模式把抽象隔离开来。
    　　
    function getBeerById(id, callback) {　　
        asyncRequest('GET', 'beer.url?id=' + id, function(resp) {　　
            callback(resp.responseText);　
        });　　
    }　　
    addEvent(element, 'click', getBeerByIdBridge);　　
    function getBeerByIdBridge(e) {　　
        getBeerById(this.id, function(beer) {　　
            console.log('Requested Beer: ' + beer);　　
        });　　
    }
    </script>
</body>

</html>
